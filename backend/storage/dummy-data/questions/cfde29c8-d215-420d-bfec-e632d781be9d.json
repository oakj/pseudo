{
    "question_id": "cfde29c8-d215-420d-bfec-e632d781be9d",
    "metadata": {
        "difficulty": "hard",
        "categories": ["string", "breadth-first search", "hash table"],
        "time_limit_ms": 2000,
        "memory_limit_mb": 256,
        "version": "1.0",
        "last_modified": "2024-03-21"
    },
    "title": "Word Ladder",
    "description": "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n- Every adjacent pair of words differs by a single letter\n- Every si for 1 <= i <= k must exist in wordList\n- Note that beginWord does not need to be in wordList\n- sk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.",
    "constraints": [
        "1 <= beginWord.length <= 10",
        "endWord.length == beginWord.length",
        "1 <= wordList.length <= 5000",
        "wordList[i].length == beginWord.length",
        "beginWord, endWord, and wordList[i] consist of lowercase English letters",
        "beginWord != endWord",
        "All words in wordList are unique",
        "All words have same length"
    ],
    "complexity_requirements": {
        "time": "O(N * 26 * L) where N is dictionary size and L is word length",
        "space": "O(N)"
    },
    "test_cases": [
        {
            "input": {
                "beginWord": "hit",
                "endWord": "cog",
                "wordList": ["hot","dot","dog","lot","log","cog"],
                "type": "word_ladder"
            },
            "output": {
                "value": 5,
                "type": "integer"
            },
            "explanation": "hit -> hot -> dot -> dog -> cog",
            "is_performance_test": false
        },
        {
            "input": {
                "beginWord": "hit",
                "endWord": "cog",
                "wordList": ["hot","dot","dog","lot","log"],
                "type": "word_ladder"
            },
            "output": {
                "value": 0,
                "type": "integer"
            },
            "explanation": "endWord 'cog' is not in wordList",
            "is_performance_test": false
        },
        {
            "input": {
                "beginWord": "a",
                "endWord": "c",
                "wordList": ["a","b","c"],
                "type": "word_ladder"
            },
            "output": {
                "value": 2,
                "type": "integer"
            },
            "explanation": "Shortest possible transformation",
            "is_performance_test": false
        },
        {
            "input": {
                "beginWord": generateWord(10),
                "endWord": generateWord(10),
                "wordList": generateWordList(5000, 10),
                "type": "word_ladder"
            },
            "output": {
                "value": "LARGE_OUTPUT",
                "type": "integer"
            },
            "explanation": "Maximum constraints test",
            "is_performance_test": true
        }
    ],
    "pseudocode_requirements": {
        "allowed_constructs": ["queue", "set", "hash table", "loops", "conditionals"],
        "required_concepts": ["breadth-first search", "string manipulation", "graph traversal"],
        "validation_rules": {
            "syntax_flexibility": "high",
            "variable_naming": "flexible"
        }
    },
    "boilerplate_solution": {
        "language": "python",
        "pseudocode": "class Solution:\n    def ladder_length(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        # TODO: Implement this function\n        # Return shortest transformation sequence length"
    },
    "valid_solutions": [
        {
            "approach": "BFS with pattern matching",
            "time_complexity": "O(N * 26 * L)",
            "space_complexity": "O(N)",
            "pseudocode": "function ladderLength(beginWord, endWord, wordList):\n    if endWord not in wordList:\n        return 0\n    \n    wordSet = set(wordList)\n    queue = [(beginWord, 1)]\n    seen = {beginWord}\n    \n    while queue:\n        word, length = queue.pop(0)\n        if word == endWord:\n            return length\n        \n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                newWord = word[:i] + c + word[i+1:]\n                if newWord in wordSet and newWord not in seen:\n                    queue.append((newWord, length + 1))\n                    seen.add(newWord)\n    \n    return 0"
        },
        {
            "approach": "bidirectional BFS",
            "time_complexity": "O(N * 26 * L)",
            "space_complexity": "O(N)",
            "pseudocode": "function ladderLength(beginWord, endWord, wordList):\n    if endWord not in wordList:\n        return 0\n    \n    front = {beginWord}\n    back = {endWord}\n    wordSet = set(wordList)\n    length = 1\n    \n    while front:\n        if len(front) > len(back):\n            front, back = back, front\n        \n        next_level = set()\n        for word in front:\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    newWord = word[:i] + c + word[i+1:]\n                    if newWord in back:\n                        return length + 1\n                    if newWord in wordSet:\n                        next_level.add(newWord)\n                        wordSet.remove(newWord)\n        \n        front = next_level\n        length += 1\n    \n    return 0"
        }
    ],
    "evaluation_criteria": {
        "critical_requirements": [
            "Must find shortest transformation sequence",
            "Must handle non-existent paths",
            "Must verify endWord exists in wordList",
            "Must handle single-letter words",
            "Must process words level by level",
            "Must avoid cycles in transformation"
        ],
        "common_mistakes": [
            {
                "pattern": "Using DFS",
                "issue": "May not find shortest path",
                "suggestion": "Use BFS for shortest path"
            },
            {
                "pattern": "Not checking endWord in wordList",
                "issue": "Wastes time on impossible cases",
                "suggestion": "Check endWord existence first"
            },
            {
                "pattern": "Inefficient word comparison",
                "issue": "Checking every word pair",
                "suggestion": "Use pattern matching approach"
            }
        ],
        "scoring_rubric": {
            "correctness": {
                "weight": 40,
                "criteria": [
                    "Finds shortest path",
                    "Handles all edge cases",
                    "Correct transformation rules",
                    "Proper path length counting"
                ]
            },
            "complexity": {
                "weight": 30,
                "criteria": [
                    "Efficient word transformation",
                    "Optimal space usage",
                    "Proper BFS implementation"
                ]
            },
            "implementation": {
                "weight": 30,
                "criteria": [
                    "Clean code structure",
                    "Efficient data structure usage",
                    "Clear variable naming",
                    "Logical traversal approach"
                ]
            }
        }
    },
    "solution_breakdown": {
        "key_steps": [
            {
                "step": "Verify endWord exists",
                "purpose": "Early termination for impossible cases"
            },
            {
                "step": "Initialize BFS",
                "purpose": "Set up queue and visited set"
            },
            {
                "step": "Generate transformations",
                "purpose": "Find valid next words"
            },
            {
                "step": "Track path length",
                "purpose": "Count transformations in sequence"
            },
            {
                "step": "Handle visited words",
                "purpose": "Avoid cycles and duplicates"
            }
        ],
        "invariants": [
            "Words differ by exactly one letter",
            "All intermediate words exist in wordList",
            "No word is visited twice",
            "Path length increases by 1 per transformation",
            "BFS ensures shortest path"
        ]
    },
    "anti_patterns": [
        {
            "pattern": "Comparing all word pairs",
            "why_wrong": "O(NÂ²) complexity",
            "correction": "Use pattern matching approach"
        },
        {
            "pattern": "Using DFS",
            "why_wrong": "May not find shortest path",
            "correction": "Use BFS for shortest path guarantee"
        },
        {
            "pattern": "Not using set for wordList",
            "why_wrong": "Slow word existence checking",
            "correction": "Convert list to set for O(1) lookup"
        },
        {
            "pattern": "Recursive implementation",
            "why_wrong": "Stack overflow risk for long paths",
            "correction": "Use iterative BFS approach"
        }
    ],
    "validation_examples": {
        "incorrect_solutions": [
            {
                "code": "def ladderLength(beginWord, endWord, wordList):\n    def diff_by_one(w1, w2):\n        diff = 0\n        for c1, c2 in zip(w1, w2):\n            if c1 != c2: diff += 1\n        return diff == 1\n    \n    queue = [(beginWord, 1)]\n    while queue:\n        word, length = queue.pop(0)\n        if word == endWord: return length\n        for w in wordList:\n            if diff_by_one(word, w):\n                queue.append((w, length + 1))\n    return 0",
                "why_wrong": "Doesn't track visited words and compares all pairs",
                "feedback": "Use pattern matching and track visited words"
            },
            {
                "code": "def ladderLength(beginWord, endWord, wordList):\n    def dfs(word, visited, length):\n        if word == endWord: return length\n        min_length = float('inf')\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                newWord = word[:i] + c + word[i+1:]\n                if newWord in wordList and newWord not in visited:\n                    min_length = min(min_length, dfs(newWord, visited | {newWord}, length + 1))\n        return min_length\n    \n    return dfs(beginWord, {beginWord}, 1) if endWord in wordList else 0",
                "why_wrong": "Uses DFS which may not find shortest path",
                "feedback": "Use BFS to guarantee shortest path"
            }
        ],
        "partially_correct": [
            {
                "code": "def ladderLength(beginWord, endWord, wordList):\n    if endWord not in wordList: return 0\n    wordSet = set(wordList)\n    queue = [(beginWord, 1)]\n    \n    while queue:\n        word, length = queue.pop(0)\n        if word == endWord: return length\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                newWord = word[:i] + c + word[i+1:]\n                if newWord in wordSet:\n                    queue.append((newWord, length + 1))\n                    wordSet.remove(newWord)\n    return 0",
                "issues": [
                    "Modifies wordSet which may be needed later",
                    "Could use separate visited set"
                ],
                "feedback": "Use separate visited set instead of modifying wordSet"
            }
        ]
    }
} 